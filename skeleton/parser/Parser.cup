package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, LPAREN, RPAREN;
terminal RETURN, MULT, MINUS, SEMI, UMINUS;
terminal IF, LE, GE, EQ, NE, LT, GT, NOT, AND, OR;
terminal EMPTY;
terminal Long    INTCONST;

non terminal Program         program;
non terminal Return          return;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal Stmt            stmt;
non terminal StmtList        stmtList;
non terminal Cond           cond;


precedence left PLUS, MINUS;
precedence left MULT;
precedence left UMINUS;
//precedence left ELSE; // resolves dangling else

start with program;

program ::= stmtList:sl
            {: RESULT = new Program(sl, loc(slleft, slright)); :}
         ;

stmtList ::= stmt:s stmtList:sl
            {: RESULT = new Program(sl, loc(slleft, slright)); :}
         | EMPTY
         ;

stmt ::= RETURN expr:e SEMI
         {: RESULT = new Return(e, loc(eleft, eright)); :}
      |  IF LPAREN cond:c RPAREN stmt:s
         {: RESULT = new IfStmt(c, s, loc(cleft, cright)); :}
      ;

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      |  MINUS expr:e 
         {: RESULT = new UnaryExpr(e, loc(eleft, eright)); :}
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.BMINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MULT expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MULT, e2, loc(e1left, e1right)); :}
            ;

cond ::= expr:e1 LE expr:e2
            {: RESULT = new CondExpr(e1, Cond.LE, e2, loc(e1left, e1right)); :}
      |  expr:e1 GE expr:e2
            {: RESULT = new CondExpr(e1, Cond.GE, e2, loc(e1left, e1right)); :}
      | expr:e1 EQ expr:e2
            {: RESULT = new CondExpr(e1, Cond.EQ, e2, loc(e1left, e1right)); :}
      | expr:e1 NE expr:e2
            {: RESULT = new CondExpr(e1, Cond.NE, e2, loc(e1left, e1right)); :}
      | expr:e1 LT expr:e2
            {: RESULT = new CondExpr(e1, Cond.LT, e2, loc(e1left, e1right)); :}
      | expr:e1 GT expr:e2
            {: RESULT = new CondExpr(e1, Cond.GT, e2, loc(e1left, e1right)); :}
      | cond:c1 AND cond:c2
            {: RESULT = new Cond(c1, Cond.AND, c2, loc(c1left, c1right)); :}
      | cond:c1 OR cond:c2
            {: RESULT = new Cond(c1, Cond.OR, c2, loc(c1left, c1right)); :}
      | NOT cond:c
            {: RESULT = new Cond(nil, Cond.NOT, c, loc(cleft, cright)); :}
      | LPAREN cond:c RPAREN
            {: RESULT = c; :}
      ;
